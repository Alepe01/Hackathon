<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estación Lunar 3D - VR</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
            z-index: 100;
        }
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            font-size: 16px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 100;
            font-weight: bold;
        }
        #vrButton:hover {
            background: #357abd;
        }
        #vrButton:disabled {
            background: #666;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="controls">
        <strong>Controles PC:</strong><br>
        WASD - Mover<br>
        Mouse - Girar cámara<br>
        Espacio - Subir<br>
        Shift - Bajar<br><br>
        <strong>VR:</strong> Usa el botón abajo
    </div>
    <button id="vrButton">ENTRAR A VR</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        let scene, camera, renderer;
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let mouseX = 0, mouseY = 0;
        let isPointerLocked = false;
        let vrButton;
        let isVRMode = false;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000814);
            scene.fog = new THREE.Fog(0x000814, 0, 500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Configurar botón VR
            vrButton = document.getElementById('vrButton');
            
            // Verificar si VR está disponible
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.addEventListener('click', onVRButtonClick);
                        vrButton.textContent = 'ENTRAR A VR';
                    } else {
                        vrButton.textContent = 'VR NO DISPONIBLE';
                        vrButton.disabled = true;
                    }
                });
            } else {
                vrButton.textContent = 'VR NO SOPORTADO';
                vrButton.disabled = true;
            }

            // Luces
            const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);

            // Piso lunar
            const floorGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x8a8a8a,
                roughness: 0.9,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            
            const vertices = floorGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] += Math.random() * 0.5;
            }
            floorGeometry.attributes.position.needsUpdate = true;
            floorGeometry.computeVertexNormals();
            
            scene.add(floor);

            // Primera cúpula (grande)
            const dome1Geometry = new THREE.SphereGeometry(8, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            const dome1Material = new THREE.MeshStandardMaterial({
                color: 0x2a4858,
                roughness: 0.3,
                metalness: 0.8,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const dome1 = new THREE.Mesh(dome1Geometry, dome1Material);
            dome1.position.set(-12, 0, 0);
            dome1.castShadow = true;
            dome1.receiveShadow = true;
            scene.add(dome1);

            // Marco de la cúpula 1
            const frameGeometry1 = new THREE.TorusGeometry(8, 0.2, 8, 32);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.2,
                metalness: 0.9
            });
            const frame1 = new THREE.Mesh(frameGeometry1, frameMaterial);
            frame1.position.set(-12, 0, 0);
            frame1.rotation.x = Math.PI / 2;
            frame1.castShadow = true;
            scene.add(frame1);

            // Segunda cúpula (mediana)
            const dome2Geometry = new THREE.SphereGeometry(6, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            const dome2Material = new THREE.MeshStandardMaterial({
                color: 0x3a5868,
                roughness: 0.3,
                metalness: 0.8,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const dome2 = new THREE.Mesh(dome2Geometry, dome2Material);
            dome2.position.set(10, 0, -8);
            dome2.castShadow = true;
            dome2.receiveShadow = true;
            scene.add(dome2);

            // Marco de la cúpula 2
            const frame2 = new THREE.Mesh(
                new THREE.TorusGeometry(6, 0.15, 8, 32),
                frameMaterial
            );
            frame2.position.set(10, 0, -8);
            frame2.rotation.x = Math.PI / 2;
            frame2.castShadow = true;
            scene.add(frame2);

            // Túnel conector
            const tunnelGeometry = new THREE.CylinderGeometry(2, 2, 12, 16);
            const tunnelMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a5858,
                roughness: 0.5,
                metalness: 0.7
            });
            const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.position.set(-1, 1.5, -4);
            tunnel.rotation.z = Math.PI / 2;
            tunnel.castShadow = true;
            tunnel.receiveShadow = true;
            scene.add(tunnel);

            // Luces interiores en las cúpulas
            const light1 = new THREE.PointLight(0x00ffff, 1, 20);
            light1.position.set(-12, 4, 0);
            scene.add(light1);

            const light2 = new THREE.PointLight(0x00ff88, 1, 15);
            light2.position.set(10, 3, -8);
            scene.add(light2);

            // Agregar estrellas
            const starsGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for (let i = 0; i < 3000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = Math.random() * 500 + 100;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);

            // Controles de teclado
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', () => {
                if (!isVRMode) {
                    document.body.requestPointerLock();
                }
            });
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
            });
            document.addEventListener('mousemove', onMouseMove);

            window.addEventListener('resize', onWindowResize);

            // Listener para cuando se sale de VR
            renderer.xr.addEventListener('sessionstart', () => {
                isVRMode = true;
                vrButton.textContent = 'SALIR DE VR';
            });
            
            renderer.xr.addEventListener('sessionend', () => {
                isVRMode = false;
                vrButton.textContent = 'ENTRAR A VR';
            });
        }

        async function onVRButtonClick() {
            if (!isVRMode) {
                const sessionInit = {
                    optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                };
                const session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                renderer.xr.setSession(session);
            } else {
                renderer.xr.getSession().end();
            }
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': moveUp = true; e.preventDefault(); break;
                case 'ShiftLeft': moveDown = true; break;
            }
        }

        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'Space': moveUp = false; break;
                case 'ShiftLeft': moveDown = false; break;
            }
        }

        function onMouseMove(e) {
            if (!isPointerLocked) return;
            
            mouseX = e.movementX || 0;
            mouseY = e.movementY || 0;

            euler.setFromQuaternion(camera.quaternion);
            euler.y -= mouseX * 0.002;
            euler.x -= mouseY * 0.002;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            camera.quaternion.setFromEuler(euler);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            // Solo aplicar movimiento de teclado si no estamos en VR
            if (!isVRMode) {
                velocity.x -= velocity.x * 10.0 * 0.016;
                velocity.z -= velocity.z * 10.0 * 0.016;
                velocity.y -= velocity.y * 10.0 * 0.016;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.y = Number(moveUp) - Number(moveDown);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * 0.016;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * 0.016;
                if (moveUp || moveDown) velocity.y += direction.y * 100.0 * 0.016;

                camera.translateX(-velocity.x * 0.016);
                camera.translateY(velocity.y * 0.016);
                camera.translateZ(-velocity.z * 0.016);

                if (camera.position.y < 2) camera.position.y = 2;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
