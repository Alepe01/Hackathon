<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Habitat Designer - Full System</title>
    <style>
        /* Estilos CSS (Sin cambios, pero incluye los estilos del Layout Planner) */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; overflow-x: hidden; }
        
        .instruction-box { background: rgba(0,168,232,0.1); border-left: 4px solid #00a8e8; padding: 15px 20px; margin: 20px 0; border-radius: 5px; color: #00d9ff; font-size: 14px; }
        .instruction-box strong { color: #00ff88; }
        
        .presentation-screen { display: none; min-height: 100vh; background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #0f0f1e 100%); color: #fff; align-items: center; justify-content: center; padding: 40px; }
        .presentation-screen.active { display: flex; }
        .presentation-content { max-width: 1400px; width: 100%; }
        .presentation-screen h1 { font-size: 48px; text-align: center; margin-bottom: 20px; color: #00ff88; text-shadow: 0 0 20px rgba(0,255,136,0.5); }
        .presentation-screen h2 { font-size: 32px; margin-bottom: 30px; color: #00a8e8; }
        .presentation-screen p { font-size: 18px; line-height: 1.6; margin-bottom: 30px; color: #ccc; }
        
        .btn-presentation { padding: 15px 40px; font-size: 18px; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s; margin: 10px; background: linear-gradient(135deg, #00ff88, #00cc70); color: #000; }
        .btn-presentation:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(0,255,136,0.4); }
        .btn-secondary-pres { background: linear-gradient(135deg, #00a8e8, #0077b6); color: #fff; }
        .center { text-align: center; }
        
        .destination-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 30px; margin: 40px 0; }
        .destination-card { background: rgba(255,255,255,0.05); border: 2px solid rgba(0,168,232,0.3); border-radius: 15px; padding: 30px; cursor: pointer; transition: all 0.3s; }
        .destination-card:hover { border-color: #00ff88; transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0,255,136,0.3); }
        .destination-card.selected { border-color: #00ff88; background: rgba(0,255,136,0.1); }
        .destination-card h3 { font-size: 28px; margin-bottom: 15px; color: #00a8e8; }
        
        .designer-screen { display: none; min-height: 100vh; padding: 20px; }
        .designer-screen.active { display: block; }
        .container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 15px; padding: 30px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); }
        
        h1 { color: #333; margin-bottom: 30px; text-align: center; }
        h2 { color: #555; margin: 20px 0; padding-bottom: 10px; border-bottom: 2px solid #667eea; }
        h3 { color: #666; margin: 15px 0; }
        
        .input-group { display: flex; gap: 15px; align-items: center; margin: 20px 0; justify-content: center; }
        .input-group label { font-weight: 600; font-size: 18px; }
        .input-group input[type="number"] { padding: 10px; font-size: 16px; border: 2px solid #ddd; border-radius: 8px; width: 100px; text-align: center; }
        
        .btn { background: #667eea; color: white; border: none; padding: 12px 30px; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s; display: block; margin: 20px auto; }
        .btn:hover { background: #5568d3; transform: translateY(-2px); }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        
        .building-list { list-style: none; margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; }
        .building-list li { padding: 20px; background: #f8f9fa; border-radius: 8px; cursor: pointer; transition: all 0.3s; text-align: center; border: 2px solid transparent; }
        .building-list li:hover { background: #e9ecef; border-color: #667eea; transform: scale(1.05); }
        .building-list li strong { display: block; font-size: 18px; color: #333; }
        .building-list li .status { font-size: 14px; margin-top: 8px; color: #28a745; font-weight: 500; }
        
        .designer-container { display: flex; gap: 30px; margin-top: 20px; }
        .grid-container { flex: 1; background: #f8f9fa; padding: 20px; border-radius: 8px; }
        .building-grid { display: grid; grid-template-columns: repeat(6, 80px); grid-template-rows: repeat(4, 80px); gap: 2px; background: #ccc; border: 3px solid #333; margin-bottom: 20px; position: relative; }
        .module-grid { display: grid; grid-template-columns: repeat(8, 50px); grid-template-rows: repeat(10, 50px); gap: 1px; background: #ccc; border: 2px solid #333; margin-bottom: 20px; position: relative; }
        .grid-cell { background: white; border: 1px solid #ddd; position: relative; }
        
        .objects-panel { width: 300px; background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 600px; overflow-y: auto; }
        .object-item { padding: 12px; margin: 8px 0; background: white; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: all 0.3s; }
        .object-item:hover { border-color: #667eea; transform: scale(1.02); }
        .object-item.selected { border-color: #667eea; background: #f0f4ff; }
        
        .controls { margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        .btn-small { padding: 8px 16px; font-size: 14px; }
        .hidden { display: none; }
        .back-btn { background: #6c757d; margin-bottom: 20px; }
        .back-btn:hover { background: #5a6268; }
        .rotate-btn { background: #28a745; }
        .rotate-btn:hover { background: #218838; }
        .reset-btn { background: #dc3545; }
        .reset-btn:hover { background: #c82333; }
        
        .placed-module, .placed-object { position: absolute; background: rgba(102,126,234,0.8); border: 3px solid #667eea; display: flex; align-items: center; justify-content: center; color: white; font-size: 13px; font-weight: bold; text-align: center; padding: 5px; cursor: grab; z-index: 10; user-select: none; }
        .placed-module:active, .placed-object:active { cursor: grabbing; }
        .placed-module:hover, .placed-object:hover { background: rgba(102,126,234,0.95); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        
        .object-dimensions { font-size: 11px; color: #666; }
        .breadcrumb { background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-size: 14px; color: #666; }
        .breadcrumb strong { color: #333; }
        
        .preview-container { background: #fff; border: 2px solid #667eea; border-radius: 8px; padding: 15px; margin: 15px 0; text-align: center; }
        .preview-title { font-size: 14px; font-weight: 600; color: #667eea; margin-bottom: 10px; }
        .preview-grid { display: inline-grid; gap: 1px; background: #ddd; border: 2px solid #333; margin: 10px auto; }
        .preview-cell { width: 20px; height: 20px; background: white; }
        .preview-cell.filled { background: #667eea; }
        .preview-info { font-size: 12px; color: #666; margin-top: 8px; }
        .rotation-display { display: inline-block; background: #28a745; color: white; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; margin-top: 5px; }
        
        .ghost-preview { position: fixed; pointer-events: none; z-index: 1000; opacity: 0.6; border: 3px dashed #667eea; background: rgba(102,126,234,0.3); display: none; color: white; font-weight: bold; text-align: center; align-items: center; justify-content: center; font-size: 11px; }
        .ghost-preview.valid { border-color: #28a745; background: rgba(40,167,69,0.3); }
        .ghost-preview.invalid { border-color: #dc3545; background: rgba(220,53,69,0.3); }
        
        .viewer-3d { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000814; z-index: 10000; }
        .viewer-3d.active { display: block; }
        .viewer-3d canvas { display: block; width: 100%; height: 100%; }
        
        #controls-3d { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; font-size: 14px; line-height: 1.6; z-index: 100; }
        #view2DButton { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; font-size: 16px; background: #28a745; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 100; font-weight: bold; }
        #view2DButton:hover { background: #218838; }
        #vrButton { position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%); padding: 12px 24px; font-size: 16px; background: #4a90e2; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 100; font-weight: bold; }
        #vrButton:hover { background: #357abd; }
        #vrButton:disabled { background: #666; cursor: not-allowed; }
        
        .view-2d-container { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a2e; z-index: 9999; overflow: auto; padding: 20px; }
        .view-2d-container.active { display: block; }
        .view-2d-header { background: rgba(0,168,232,0.1); border: 2px solid #00a8e8; border-radius: 10px; padding: 20px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; }
        .building-2d-view { background: rgba(255,255,255,0.05); border: 2px solid #00a8e8; border-radius: 15px; padding: 30px; margin-bottom: 30px; }
        .building-2d-grid { display: grid; grid-template-columns: repeat(6, 100px); grid-template-rows: repeat(4, 100px); gap: 3px; background: #333; border: 3px solid #00ff88; margin: 20px 0; position: relative; }
        .building-2d-cell { background: #2a2a3e; border: 1px solid #444; position: relative; }
        .module-2d-view { position: absolute; background: rgba(102,126,234,0.6); border: 2px solid #00ff88; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s; }
        .module-2d-view:hover { background: rgba(102,126,234,0.9); transform: scale(1.05); z-index: 10; }
        .module-2d-detail { background: rgba(0,0,0,0.9); border: 3px solid #00ff88; border-radius: 15px; padding: 30px; margin-top: 20px; }
        .module-2d-objects-grid { display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(10, 60px); gap: 2px; background: #222; border: 2px solid #00a8e8; margin: 20px 0; position: relative; }
        .module-2d-cell { background: #1a1a2e; border: 1px solid #333; }
        .object-2d-view { 
            position: absolute; 
            background: rgba(40,167,69,0.7); 
            border: 2px solid #00ff88; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            color: white; 
            font-size: 10px; 
            font-weight: bold; 
            text-align: center; 
            padding: 2px; 
            overflow: hidden; /* Oculta texto si hay imagen */
        }
        .object-2d-view img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Estilos específicos del Layout Planner */
        #layoutGrid { display: inline-grid; grid-template-columns: repeat(80, 15px); grid-template-rows: repeat(80, 15px); gap: 0; border: 2px solid #00ff88; background: white; position: relative; user-select: none; }
        .layout-cell { width: 15px; height: 15px; border: 1px solid #ddd; background: white; position: relative; }
        .layout-cell.interior { background: #9e9e9e; }
        .layout-cell:hover { background: #e9ecef; }
        .layout-cell.interior:hover { opacity: 0.8; }
        .layout-cell.interior.delete-mode:hover { cursor: pointer; background: #ff5722 !important; }
        .layout-module-circle { position: absolute; border: 5px solid; border-radius: 50%; pointer-events: none; z-index: 10; }
        .layout-module-circle.small-circle { border-color: #dc3545; }
        .layout-module-circle.medium-circle { border-color: #28a745; }
        .layout-module-circle.large-circle { border-color: #007bff; }
        .layout-door { position: absolute; background: #795548; pointer-events: all; z-index: 11; cursor: pointer; transition: all 0.2s; }
        .layout-door:hover { background: #5d4037; transform: scale(1.1); }
        .layout-door.selected { background: #ff9800; box-shadow: 0 0 10px #ff9800; }
        .layout-tunnel { position: absolute; background: #616161; pointer-events: all; z-index: 9; cursor: pointer; transition: all 0.2s; }
        .layout-tunnel:hover { background: #424242; }
        .structure-option { background: rgba(0,168,232,0.1); padding: 15px; margin-bottom: 10px; border-radius: 6px; cursor: pointer; border: 2px solid transparent; transition: all 0.3s; color: white; }
        .structure-option:hover { background: rgba(0,168,232,0.2); border-color: #00a8e8; }
        .structure-option.selected { background: #00a8e8; border-color: #00ff88; }
        .structure-option h4 { margin-bottom: 5px; font-size: 16px; }
        .structure-option p { font-size: 14px; opacity: 0.8; }
    </style>
</head>
<body>
    <div class="presentation-screen active" id="screen-welcome">
        <div class="presentation-content center">
            <h1>🚀 Space Habitat Designer</h1>
            <p style="font-size: 24px;">Complete Design and Simulation System for Space Habitats</p>
            <div class="instruction-box" style="max-width: 800px; margin: 30px auto;">
                <strong>Welcome!</strong><br>
                This tool allows you to design complete space habitats by configuring habitat structures, pressurized compartments, and internal equipment.
            </div>
            <button class="btn-presentation" onclick="goToScreen('screen-destination')">Start Design →</button>
        </div>
    </div>

    <div class="presentation-screen" id="screen-destination">
        <div class="presentation-content">
            <h2>Select Your Mission Destination</h2>
            <p>Choose the celestial body where you will establish your habitat</p>
            <div class="destination-grid">
                <div class="destination-card" onclick="selectDestination('moon')">
                    <h3>🌙 Moon</h3>
                    <p>Distance: 384,400 km</p>
                    <p>Gravity: 1.62 m/s²</p>
                </div>
                <div class="destination-card" onclick="selectDestination('mars')">
                    <h3>🔴 Mars</h3>
                    <p>Distance: 225M km (avg)</p>
                    <p>Gravity: 3.71 m/s²</p>
                </div>
                <div class="destination-card" onclick="selectDestination('europa')">
                    <h3>🪐 Europa</h3>
                    <p>Distance: 628M km (avg)</p>
                    <p>Gravity: 1.31 m/s²</p>
                </div>
            </div>
            <div class="center">
                <button class="btn-presentation btn-secondary-pres" onclick="goToScreen('screen-welcome')">← Back</button>
                <button class="btn-presentation" id="btn-start-design" disabled onclick="startDesign()">Begin Configuration →</button>
            </div>
        </div>
    </div>

    <div class="presentation-screen" id="screen-config">
        <div class="presentation-content">
            <h2>Mission Parameters</h2>
            <p>Define your mission duration and crew size</p>
            <div style="background: rgba(255,255,255,0.05); border: 1px solid rgba(0,168,232,0.3); border-radius: 10px; padding: 30px; margin: 20px 0;">
                <h3 style="color: #00a8e8; margin-bottom: 20px;">General Configuration</h3>
                <div style="margin-bottom: 25px;">
                    <label style="display: block; font-size: 16px; margin-bottom: 10px; color: #00ff88; font-weight: bold;">Mission Duration (years)</label>
                    <input type="number" id="mission-duration" min="1" max="15" value="5" onchange="updateResourceCalculations()" 
                            style="width: 100%; padding: 12px; font-size: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(0,168,232,0.5); border-radius: 5px; color: #fff;">
                </div>
                <div style="margin-bottom: 25px;">
                    <label style="display: block; font-size: 16px; margin-bottom: 10px; color: #00ff88; font-weight: bold;">Number of Astronauts</label>
                    <input type="number" id="crew-size" min="1" max="50" value="6" onchange="updateResourceCalculations()" 
                            style="width: 100%; padding: 12px; font-size: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(0,168,232,0.5); border-radius: 5px; color: #fff;">
                </div>
                <div style="background: rgba(0,168,232,0.1); border-left: 4px solid #00a8e8; padding: 15px; border-radius: 5px;">
                    <strong style="color: #00a8e8;">Estimated Daily Resources:</strong>
                    <div id="resource-calculations" style="margin-top: 10px; color: #ccc; font-size: 14px;"></div>
                </div>
            </div>
            <div class="center">
                <button class="btn-presentation btn-secondary-pres" onclick="proceedToDesign()">Continue to Designer →</button>
            </div>
        </div>
    </div>

    <div class="designer-screen" id="designer-main">
        <div class="container">
            <div id="page0">
                <h1>🏗️ Habitat Structure Configuration</h1>
                <h2>Define the number of habitat structures needed</h2>
                <div class="instruction-box">
                    <strong>What is a Habitat Structure?</strong><br>
                    A pressurized building that contains multiple compartments. Most missions have 1-3 structures.
                </div>
                <div class="input-group">
                    <label for="numBuildings">Number of Habitat Structures:</label>
                    <input type="number" id="numBuildings" min="1" max="10" value="1">
                </div>
                <button class="btn" onclick="createBuildings()">Continue →</button>
            </div>

            <div id="page2" class="hidden">
                <h1>Habitat Structures Overview</h1>
                <div class="instruction-box">
                    <strong>Next Step:</strong> Click on any structure below to start designing its interior compartment layout.
                </div>
                <h2>Select a structure to design its compartment layout</h2>
                <ul class="building-list" id="buildingsList"></ul>
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn" onclick="openLayoutPlanner()">✓ Continue to Layout Planner</button>
                    <button class="btn back-btn btn-small" onclick="goToPage0()">← Back</button>
                </div>
            </div>

            <div id="page3" class="hidden">
                <h1 id="currentBuildingTitle"></h1>
                <div class="breadcrumb"><strong>Designing:</strong> <span id="currentBuildingName"></span></div>
                <div class="instruction-box">
                    <strong>Compartment Placement:</strong> Click compartment → Click grid → Double-click to design interior
                </div>
                <div class="designer-container">
                    <div class="grid-container">
                        <h3>Structure Grid (30m × 20m)</h3>
                        <div class="building-grid" id="buildingGrid"></div>
                        <div class="ghost-preview" id="moduleGhost"></div>
                        <div class="controls">
                            <button class="btn btn-small reset-btn" onclick="resetBuilding()">🗑️ Clear All</button>
                        </div>
                    </div>
                    <div class="objects-panel">
                        <h3>Available Compartments</h3>
                        <div id="modulesList"></div>
                    </div>
                </div>
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn back-btn btn-small" onclick="goToPage2()">← Back</button>
                </div>
            </div>

            <div id="page5" class="hidden">
                <h1 id="currentModuleTitle"></h1>
                <div class="breadcrumb"><strong>Structure:</strong> <span id="breadcrumbBuilding"></span> → <strong>Compartment:</strong> <span id="breadcrumbModule"></span></div>
                <div class="instruction-box">
                    <strong>Equipment Placement:</strong> Select equipment → Rotate if needed → Click grid to place
                </div>
                <div class="designer-container">
                    <div class="grid-container">
                        <h3>Compartment Grid (4m × 5m)</h3>
                        <div class="module-grid" id="moduleGrid"></div>
                        <div class="ghost-preview" id="objectGhost"></div>
                        <div class="controls">
                            <button class="btn btn-small reset-btn" onclick="resetModule()">🗑️ Clear All</button>
                        </div>
                    </div>
                    <div class="objects-panel">
                        <h3>Available Equipment</h3>
                        <div id="objectPreview" class="preview-container hidden">
                            <div class="preview-title">Preview</div>
                            <div id="previewGrid" class="preview-grid"></div>
                            <div class="preview-info">
                                <div id="previewDimensions"></div>
                                <div class="rotation-display" id="previewRotation">0°</div>
                            </div>
                            <button class="btn btn-small rotate-btn" style="margin: 10px auto 0;" onclick="rotateObjectPreview()">🔄 Rotate</button>
                        </div>
                        <div id="objectsList"></div>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                    <button class="btn btn-small" style="background: #28a745;" onclick="saveAndGoBack()">✓ Save</button>
                    <button class="btn back-btn btn-small" onclick="goToPage3FromModule()">← Discard</button>
                </div>
            </div>
        </div>
    </div>

    <div class="viewer-3d" id="viewer3d">
        <div id="controls-3d">
            <strong>PC Controls:</strong><br>
            WASD - Move<br>
            Mouse - Rotate camera<br>
            Space - Ascend<br>
            Shift - Descend
        </div>
        <button id="view2DButton" onclick="open2DView()">🗺️ View 2D Plans</button>
        <button id="vrButton" onclick="enterVR()">🥽 Enter VR (Mobile Only)</button>
    </div>

    <div class="view-2d-container" id="view2d">
        <div class="view-2d-header">
            <h1 style="color: #00ff88; margin: 0;">📐 2D Plans View</h1>
            <button class="btn-presentation" onclick="close2DView()">← Back to 3D</button>
        </div>
        <div id="buildings-2d-container"></div>
    </div>

    <div class="view-2d-container" id="viewLayout">
        <div class="view-2d-header">
            <h1 style="color: #00ff88; margin: 0;">🏗️ Habitat Layout Planner</h1>
            <button class="btn-presentation" onclick="closeLayoutView()">Continue to 3D →</button>
        </div>
        <div style="padding: 20px;">
            <div class="info-box">
                <strong>Instructions:</strong><br>
                1. Select a structure size<br>
                2. Click on the grid to place it<br>
                3. Drag structures to move them<br>
                4. Click "Connect Doors" to link structures with tunnels<br>
                5. Each cell = 0.5m
            </div>
            <div style="display: flex; gap: 20px; margin-top: 20px;">
                <div style="width: 250px; background: rgba(0,168,232,0.1); padding: 20px; border-radius: 10px;">
                    <h3 style="color: #00a8e8; margin-bottom: 15px;">Available Structures</h3>
                    <div id="structureSizeSelector"></div>
                    <div style="margin-top: 20px;">
                        <button class="btn-presentation" onclick="toggleLayoutConnectMode()" id="layoutConnectBtn" style="background: #28a745; width: 100%; margin-bottom: 10px;">Connect Doors</button>
                        <button class="btn-presentation" onclick="toggleLayoutDeleteMode()" id="layoutDeleteBtn" style="background: #ff5722; width: 100%; margin-bottom: 10px;">Delete Objects</button>
                        <button class="btn-presentation" onclick="clearLayoutGrid()" style="background: #dc3545; width: 100%;">Clear All</button>
                    </div>
                    <div id="layoutModeIndicator" style="margin-top: 15px; padding: 10px; background: #cce5ff; border-radius: 6px; font-size: 14px; font-weight: bold; text-align: center;">
                        Mode: Move Structures
                    </div>
                </div>
                <div style="flex: 1; background: white; padding: 20px; border-radius: 10px;">
                    <h3 style="color: #00a8e8; margin-bottom: 15px;">Layout Grid (40m × 40m)</h3>
                    <div id="layoutGrid"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variables globales
        let currentDestination = null;
        let habitatStructures = [], selectedCompartmentTypes = [], currentStructureIndex = null, currentCompartmentInstance = null, tempCompartmentBackup = null;
        let selectedCompartmentType = null;
        let currentRotation = 0, selectedEquipment = null;
        
        let scene, camera, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        let velocity = new THREE.Vector3(), direction = new THREE.Vector3(), euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let isPointerLocked = false;
        let isVRMode = false;

        // Variables del Layout planner 
        const layoutGridSize = 80;
        const layoutCellSize = 15;
        const layoutModuleSizes = { small: 8, medium: 10, large: 12 };
        let layoutGridData = Array(layoutGridSize).fill(null).map(() => Array(layoutGridSize).fill(null));
        let layoutModulesPlaced = [];
        let selectedLayoutSize = null;
        let draggingLayoutModule = null;
        let isDraggingLayout = false;
        let layoutConnectMode = false;
        let layoutDeleteMode = false;
        let selectedLayoutDoor1 = null;
        let selectedLayoutDoor2 = null;
        let layoutTunnels = [];
        let layoutDoors = [];
        let structureAssignments = {};
        
        // CORRECCIÓN: Nuevos datos con dimensiones reales (metros) y nombres (para la imagen)
        const compartmentTypes = {
            "M1 Exercise": { objects: { 
                "Cycling ergometer": { w: 1.0, h: 1.5, img: 'a.png' }, // 2x3 celdas
                "Treadmill": { w: 1.0, h: 2.0, img: 'b.png' }, // 2x4 celdas
                "Bench station": { w: 1.5, h: 2.0, img: 'c.png' } // 3x4 celdas
            }},
            "M2 Recreational activities": { objects: { 
                "Athletic games": { w: 2.5, h: 2.5, img: 'd.png' }, // 5x5 celdas
                "Movie viewing": { w: 1.5, h: 2.0, img: 'e.png' } // 3x4 celdas
            }},
            "M3 Human testing": { objects: { 
                "Vital testing": { w: 2.5, h: 2.0, img: 'f.png' }, 
                "Waste collection": { w: 3.0, h: 2.0, img: 'g.png' }
            }},
            "M4 Hygiene": { objects: { 
                "Bathroom": { w: 3.0, h: 2.0, img: 'h.png' }
            }},
            "M5 Logistic": { objects: { 
                "Storage": { w: 3.0, h: 2.0, img: 'i.png' }
            }},
            "M6 Workstations": { objects: { 
                "Computer": { w: 3.0, h: 2.0, img: 'j.png' }, 
                "Work surface": { w: 3.0, h: 2.0, img: 'k.png' }
            }},
            "M7 Meal preparation": { objects: { 
                "Food prep": { w: 3.0, h: 2.0, img: 'l.png' }, 
                "Work surface": { w: 3.0, h: 2.0, img: 'm.png' }
            }},
            "M8 Meeting": { objects: { 
                "Work surface": { w: 3.0, h: 2.0, img: 'n.png' }, 
                "Computer": { w: 3.0, h: 2.0, img: 'o.png' }
            }},
            "M9 Command": { objects: { 
                "Computer/command": { w: 3.0, h: 2.0, img: 'p.png' }
            }},
            "M10 Private habitation": { objects: { 
                "Work surface": { w: 3.0, h: 2.0, img: 'q.png' }, 
                "Sleep area": { w: 3.0, h: 2.0, img: 'r.png' }
            }},
            "M11 Waste management": { objects: { 
                "Containment": { w: 3.0, h: 2.0, img: 's.png' }
            }},
            "M12 Life support": { objects: { 
                "Sabatier": { w: 3.0, h: 2.0, img: 't.png' }, 
                "LiOH containers": { w: 3.0, h: 2.0, img: 'u.png' }
            }}
        };

        // **********************************************
        // FUNCIONES DE NAVEGACIÓN Y CONFIGURACIÓN
        // **********************************************

        function goToScreen(screenId) {
            document.querySelectorAll('.presentation-screen, .designer-screen, .view-2d-container, .viewer-3d').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function selectDestination(dest) {
            currentDestination = dest;
            document.querySelectorAll('.destination-card').forEach(card => card.classList.remove('selected'));
            event.target.closest('.destination-card').classList.add('selected');
            document.getElementById('btn-start-design').disabled = false;
        }

        function startDesign() {
            goToScreen('screen-config');
        }

        function updateResourceCalculations() {
            const crew = parseInt(document.getElementById('crew-size').value) || 0;
            const duration = parseInt(document.getElementById('mission-duration').value) || 0;
            const resourcesDiv = document.getElementById('resource-calculations');
            resourcesDiv.innerHTML = `
                • Oxygen: <strong>${(crew * 0.79).toFixed(2)} kg/day</strong><br>
                • CO₂ removal: <strong>${(crew * 1.0).toFixed(2)} kg/day</strong><br>
                • Water: <strong>${(crew * 3.78).toFixed(2)} kg/day</strong><br>
                • Calories: <strong>${(crew * 2150).toFixed(0)} kcal/day</strong><br>
                • Mission: <strong>${crew} astronauts × ${duration} years</strong>
            `;
        }

        function proceedToDesign() {
            goToScreen('designer-main');
            show('page0');
        }

        function createBuildings() {
            const num = parseInt(document.getElementById('numBuildings').value);
            if (num < 1 || num > 10) { alert('Number must be between 1 and 10'); return; }
            habitatStructures = Array.from({length: num}, (_, i) => ({id: i, name: `Habitat Structure ${i + 1}`, compartments: [], size: null, layoutPosition: null}));
            selectedCompartmentTypes = Object.keys(compartmentTypes);
            goToPage2();
        }

        function goToPage0() { show('page0'); hide('page2', 'page3', 'page5'); }
        function goToPage2() {
            hide('page0', 'page3', 'page5'); show('page2');
            const list = document.getElementById('buildingsList');
            list.innerHTML = '';
            habitatStructures.forEach((s, i) => {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${s.name}</strong><div class="status">${s.compartments.length} compartments</div>`;
                li.onclick = () => goToPage3(i);
                list.appendChild(li);
            });
        }
        
        // **********************************************
        // FUNCIONES DEL LAYOUT PLANNER
        // **********************************************

        function initLayoutGrid() {
            const grid = document.getElementById('layoutGrid');
            grid.innerHTML = '';
            grid.style.position = 'relative';
            
            for (let i = 0; i < layoutGridSize * layoutGridSize; i++) {
                const cell = document.createElement('div');
                cell.className = 'layout-cell';
                cell.dataset.row = Math.floor(i / layoutGridSize);
                cell.dataset.col = i % layoutGridSize;
                grid.appendChild(cell);
            }
            
            grid.addEventListener('mousedown', handleLayoutMouseDown);
            grid.addEventListener('mousemove', handleLayoutMouseMove);
            grid.addEventListener('mouseup', handleLayoutMouseUp);
            grid.addEventListener('mouseleave', handleLayoutMouseUp);
            grid.addEventListener('click', handleLayoutGridClick);

            layoutGridData = Array(layoutGridSize).fill(null).map(() => Array(layoutGridSize).fill(null));
            layoutModulesPlaced.forEach(module => placeLayoutModuleOnGrid(module));

            updateLayoutGrid();
            drawLayoutCircles();
            updateLayoutModeIndicator();
        }

        function initStructureSizeSelector() {
            const container = document.getElementById('structureSizeSelector');
            container.innerHTML = '';
            
            habitatStructures.forEach((structure, index) => {
                const option = document.createElement('div');
                option.className = 'structure-option';
                const h4 = document.createElement('h4');
                h4.textContent = structure.name;
                const p = document.createElement('p');
                p.textContent = `Size: ${structure.size || 'Select Size'}`;
                option.appendChild(h4);
                option.appendChild(p);
                option.onclick = () => showSizeOptions(index, option);
                
                const existingModule = layoutModulesPlaced.find(m => m.structureIndex === index);
                if (existingModule) {
                    option.classList.add('selected');
                    p.textContent = `Size: ${existingModule.type.charAt(0).toUpperCase() + existingModule.type.slice(1)}`;
                }
                
                container.appendChild(option);
            });
        }
        
        function openLayoutPlanner() {
            if (habitatStructures.length === 0) { alert('Please create structures first.'); return; }
            document.querySelectorAll('.presentation-screen, .designer-screen').forEach(s => s.classList.remove('active'));
            document.getElementById('viewLayout').classList.add('active');
            initLayoutGrid();
            initStructureSizeSelector();
        }

        function closeLayoutView() {
            structureAssignments = {};
            
            habitatStructures.forEach(s => {
                s.size = null;
                s.layoutPosition = null;
            });

            layoutModulesPlaced.forEach((module, index) => {
                const structureIndex = module.structureIndex;
                if (structureIndex < habitatStructures.length) {
                    habitatStructures[structureIndex].size = module.type;
                    habitatStructures[structureIndex].layoutPosition = { row: module.row, col: module.col };
                }
            });
            
            const notPlaced = habitatStructures.filter(s => s.size === null);
            if (notPlaced.length > 0) {
                 alert(`Warning: ${notPlaced.length} structures are not placed in the layout. They will not appear in the 3D model.`);
            }

            document.getElementById('viewLayout').classList.remove('active');
            
            document.querySelectorAll('.presentation-screen, .designer-screen').forEach(s => s.classList.remove('active'));
            const viewer = document.getElementById('viewer3d');
            viewer.classList.add('active');
            viewer.style.display = 'block';
            init3DViewer();
        }
        
        function showSizeOptions(structureIndex, optionEl) {
            const sizes = [
                { key: 'small', name: 'Small', size: '4.0m × 4.0m' },
                { key: 'medium', name: 'Medium', size: '5.0m × 5.0m' },
                { key: 'large', name: 'Large', size: '6.0m × 6.0m' }
            ];
            
            const existingModule = layoutModulesPlaced.find(m => m.structureIndex === structureIndex);
            if (existingModule) {
                alert('This structure is already placed. Delete it first to change size.');
                return;
            }
            
            const sizeMenu = document.createElement('div');
            sizeMenu.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 15px; border: 3px solid #00a8e8; z-index: 10000; box-shadow: 0 10px 40px rgba(0,0,0,0.5);';
            
            const title = document.createElement('h3');
            title.style.cssText = 'color: #00ff88; margin-bottom: 20px;';
            title.textContent = 'Select Size for ' + habitatStructures[structureIndex].name;
            sizeMenu.appendChild(title);
            
            sizes.forEach(size => {
                const btn = document.createElement('button');
                btn.className = 'btn-presentation';
                btn.style.cssText = 'width: 100%; margin-bottom: 10px;';
                btn.textContent = size.name + ' - ' + size.size;
                btn.onclick = () => {
                    selectedLayoutSize = { key: size.key, structureIndex: structureIndex };
                    document.body.removeChild(sizeMenu);
                    document.querySelectorAll('.structure-option').forEach(opt => opt.classList.remove('selected'));
                    optionEl.classList.add('selected');
                    updateLayoutModeIndicator();
                };
                sizeMenu.appendChild(btn);
            });
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn-presentation btn-secondary-pres';
            cancelBtn.style.cssText = 'width: 100%;';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => document.body.removeChild(sizeMenu);
            sizeMenu.appendChild(cancelBtn);
            
            document.body.appendChild(sizeMenu);
        }
        
        function handleLayoutMouseDown(e) {
            if (layoutConnectMode && e.target.classList.contains('layout-door')) {
                handleLayoutDoorClick(e.target);
                return;
            }
            if (layoutDeleteMode) return;
            
            const cell = e.target.closest('.layout-cell');
            if (!cell) return;
            
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            if (selectedLayoutSize) {
                const size = layoutModuleSizes[selectedLayoutSize.key];
                const centerRow = row - Math.floor(size / 2);
                const centerCol = col - Math.floor(size / 2);
                
                if (canPlaceLayoutModule(centerRow, centerCol, size, null)) {
                    placeLayoutModule(centerRow, centerCol, size, selectedLayoutSize.key, selectedLayoutSize.structureIndex);
                    selectedLayoutSize = null;
                    document.querySelectorAll('.structure-option').forEach(opt => opt.classList.remove('selected'));
                    initStructureSizeSelector(); 
                    updateLayoutModeIndicator();
                } else {
                    alert('Not enough space to place structure here');
                }
            } else if (!layoutConnectMode) {
                const moduleId = layoutGridData[row][col];
                if (moduleId !== null) {
                    draggingLayoutModule = layoutModulesPlaced.find(m => m.id === moduleId);
                    if (draggingLayoutModule) {
                        isDraggingLayout = true;
                    }
                }
            }
        }
        
        function handleLayoutGridClick(e) {
            if (layoutDeleteMode && e.target.classList.contains('layout-tunnel')) {
                const tunnelIndex = Array.from(document.querySelectorAll('.layout-tunnel')).indexOf(e.target);
                if (tunnelIndex >= 0) {
                    e.target.remove();
                    layoutTunnels.splice(tunnelIndex, 1);
                }
                return;
            }
            
            if (layoutDeleteMode && e.target.classList.contains('layout-cell')) {
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                const moduleId = layoutGridData[row][col];
                
                if (moduleId !== null) {
                    const moduleIndex = layoutModulesPlaced.findIndex(m => m.id === moduleId);
                    if (moduleIndex >= 0) {
                        const module = layoutModulesPlaced[moduleIndex];
                        removeLayoutModuleFromGrid(module);
                        layoutModulesPlaced.splice(moduleIndex, 1);
                        removeLayoutTunnelsForModule(module);
                        updateLayoutGrid();
                        drawLayoutCircles();
                        initStructureSizeSelector(); 
                    }
                }
            }
        }
        
        function handleLayoutMouseMove(e) {
            if (!isDraggingLayout || !draggingLayoutModule) return;
            
            const rect = document.getElementById('layoutGrid').getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const col = Math.floor(x / layoutCellSize);
            const row = Math.floor(y / layoutCellSize);
            
            if (row >= 0 && row < layoutGridSize && col >= 0 && col < layoutGridSize) {
                const size = layoutModuleSizes[draggingLayoutModule.type];
                const newRow = row - Math.floor(size / 2);
                const newCol = col - Math.floor(size / 2);
                
                if (newRow !== draggingLayoutModule.row || newCol !== draggingLayoutModule.col) {
                    removeLayoutModuleFromGrid(draggingLayoutModule);
                    
                    if (canPlaceLayoutModule(newRow, newCol, size, draggingLayoutModule.id)) {
                        draggingLayoutModule.row = newRow;
                        draggingLayoutModule.col = newCol;
                    }
                    
                    placeLayoutModuleOnGrid(draggingLayoutModule);
                    updateLayoutGrid();
                    drawLayoutCircles();
                }
            }
        }
        
        function handleLayoutMouseUp(e) {
            if (isDraggingLayout && draggingLayoutModule) {
                removeLayoutTunnelsForModule(draggingLayoutModule);
                isDraggingLayout = false;
                draggingLayoutModule = null;
                drawLayoutCircles();
            }
        }
        
        function canPlaceLayoutModule(row, col, size, excludeId) {
            if (row < 0 || col < 0 || row + size > layoutGridSize || col + size > layoutGridSize) return false;
            
            for (let i = row; i < row + size; i++) {
                for (let j = col; j < col + size; j++) {
                    if (layoutGridData[i] && layoutGridData[i][j] !== null && layoutGridData[i][j] !== excludeId) return false;
                }
            }
            return true;
        }
        
        function placeLayoutModule(row, col, size, type, structureIndex) {
            const moduleId = Date.now() + Math.random();
            const module = { id: moduleId, row: row, col: col, size: size, type: type, structureIndex: structureIndex };
            layoutModulesPlaced.push(module);
            placeLayoutModuleOnGrid(module);
            updateLayoutGrid();
            drawLayoutCircles();
        }
        
        function placeLayoutModuleOnGrid(module) {
            for (let i = module.row; i < module.row + module.size; i++) {
                for (let j = module.col; j < module.col + module.size; j++) {
                    if (i >= 0 && i < layoutGridSize && j >= 0 && j < layoutGridSize) {
                        layoutGridData[i][j] = module.id;
                    }
                }
            }
        }
        
        function removeLayoutModuleFromGrid(module) {
            for (let i = module.row; i < module.row + module.size; i++) {
                for (let j = module.col; j < module.col + module.size; j++) {
                    if (i >= 0 && i < layoutGridSize && j >= 0 && j < layoutGridSize) {
                        layoutGridData[i][j] = null;
                    }
                }
            }
        }
        
        function updateLayoutGrid() {
            const cells = document.querySelectorAll('.layout-cell');
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const moduleId = layoutGridData[row] && layoutGridData[row][col] !== undefined ? layoutGridData[row][col] : null;
                
                cell.className = 'layout-cell';
                if (moduleId !== null) cell.classList.add('interior');
                if (layoutDeleteMode && moduleId !== null) cell.classList.add('delete-mode');
            });
        }
        
        function drawLayoutCircles() {
            document.querySelectorAll('.layout-module-circle').forEach(circle => circle.remove());
            document.querySelectorAll('.layout-door').forEach(door => door.remove());
            layoutDoors = [];
            
            const grid = document.getElementById('layoutGrid');
            
            layoutModulesPlaced.forEach(module => {
                const circle = document.createElement('div');
                circle.className = `layout-module-circle ${module.type}-circle`;
                
                const squareSide = module.size * layoutCellSize;
                const diameter = squareSide * Math.sqrt(2); 
                const centerX = (module.col + module.size / 2) * layoutCellSize;
                const centerY = (module.row + module.size / 2) * layoutCellSize;
                
                circle.style.width = diameter + 'px';
                circle.style.height = diameter + 'px';
                circle.style.left = (centerX - diameter / 2) + 'px';
                circle.style.top = (centerY - diameter / 2) + 'px';
                grid.appendChild(circle);
                
                const doorWidth = 2 * layoutCellSize; // 1m de ancho
                const doorHeight = layoutCellSize * 0.4; // 0.2m de grosor
                const radius = diameter / 2;
                
                const doorPositions = [
                    { x: centerX - doorWidth / 2, y: centerY - radius - doorHeight / 2, dir: 'N' },
                    { x: centerX + radius - doorHeight / 2, y: centerY - doorWidth / 2, dir: 'E' },
                    { x: centerX - doorWidth / 2, y: centerY + radius - doorHeight / 2, dir: 'S' },
                    { x: centerX - radius - doorHeight / 2, y: centerY - doorWidth / 2, dir: 'W' }
                ];
                
                doorPositions.forEach((doorPos, index) => {
                    const door = document.createElement('div');
                    door.className = 'layout-door';
                    door.dataset.doorIndex = layoutDoors.length;
                    
                    const doorCenterX = index % 2 === 0 ? doorPos.x + doorWidth / 2 : doorPos.x + doorHeight / 2;
                    const doorCenterY = index % 2 === 0 ? doorPos.y + doorHeight / 2 : doorPos.y + doorWidth / 2;
                    
                    layoutDoors.push({ module: module, direction: doorPos.dir, centerX: doorCenterX, centerY: doorCenterY, x: doorPos.x, y: doorPos.y });
                    
                    if (index % 2 === 0) {
                        door.style.width = doorWidth + 'px';
                        door.style.height = doorHeight + 'px';
                    } else {
                        door.style.width = doorHeight + 'px';
                        door.style.height = doorWidth + 'px';
                    }
                    
                    door.style.left = doorPos.x + 'px';
                    door.style.top = doorPos.y + 'px';
                    grid.appendChild(door);
                });
            });
            drawLayoutTunnels();
        }

        function drawLayoutTunnels() {
            document.querySelectorAll('.layout-tunnel').forEach(tunnel => tunnel.remove());

            const grid = document.getElementById('layoutGrid');
            const tunnelWidth = 2 * layoutCellSize; // 1m

            layoutTunnels.forEach(tunnel => {
                const door1 = layoutDoors[tunnel.door1Index];
                const door2 = layoutDoors[tunnel.door2Index];

                if (!door1 || !door2) return;

                const isHorizontal = Math.abs(door1.centerY - door2.centerY) < layoutCellSize * 1.5;
                const tunnelElement = document.createElement('div');
                tunnelElement.className = 'layout-tunnel';

                if (isHorizontal) {
                    const minX = Math.min(door1.centerX, door2.centerX);
                    const maxX = Math.max(door1.centerX, door2.centerX);
                    const length = maxX - minX;
                    
                    tunnelElement.style.left = minX + 'px';
                    tunnelElement.style.top = (door1.centerY - tunnelWidth / 2) + 'px';
                    tunnelElement.style.width = length + 'px';
                    tunnelElement.style.height = tunnelWidth + 'px';
                } else { // Vertical
                    const minY = Math.min(door1.centerY, door2.centerY);
                    const maxY = Math.max(door1.centerY, door2.centerY);
                    const length = maxY - minY;
                    
                    tunnelElement.style.left = (door1.centerX - tunnelWidth / 2) + 'px';
                    tunnelElement.style.top = minY + 'px';
                    tunnelElement.style.width = tunnelWidth + 'px';
                    tunnelElement.style.height = length + 'px';
                }
                
                grid.appendChild(tunnelElement);
            });
        }

        function handleLayoutDoorClick(doorElement) {
            const doorIndex = parseInt(doorElement.dataset.doorIndex);
            const doorData = layoutDoors[doorIndex];

            if (!selectedLayoutDoor1) {
                selectedLayoutDoor1 = { element: doorElement, data: doorData, index: doorIndex };
                doorElement.classList.add('selected');
            } else if (selectedLayoutDoor1.index === doorIndex) {
                selectedLayoutDoor1 = null;
                doorElement.classList.remove('selected');
            } else {
                selectedLayoutDoor2 = { element: doorElement, data: doorData, index: doorIndex };
                doorElement.classList.add('selected');
                
                if (canCreateTunnel(selectedLayoutDoor1.data, selectedLayoutDoor2.data)) {
                    createTunnel(selectedLayoutDoor1.index, selectedLayoutDoor2.index);
                    
                    selectedLayoutDoor1.element.classList.remove('selected');
                    selectedLayoutDoor2.element.classList.remove('selected');
                    selectedLayoutDoor1 = null;
                    selectedLayoutDoor2 = null;
                    drawLayoutCircles(); 
                } else {
                    alert('Cannot create tunnel: connection must be straight, aligned, and without obstacles.');
                    
                    selectedLayoutDoor1.element.classList.remove('selected');
                    doorElement.classList.remove('selected');
                    selectedLayoutDoor1 = null;
                    selectedLayoutDoor2 = null;
                }
            }
        }

        function canCreateTunnel(door1, door2) {
            if (door1.module.id === door2.module.id) {
                return false;
            }
            
            const isHorizontal = Math.abs(door1.centerY - door2.centerY) < layoutCellSize * 1.5;
            const isVertical = Math.abs(door1.centerX - door2.centerX) < layoutCellSize * 1.5;

            if (!isHorizontal && !isVertical) {
                return false;
            }

            const module1Id = door1.module.id;
            const module2Id = door2.module.id;
            const tunnelWidth = 2 * layoutCellSize;
            
            if (isHorizontal) {
                const y = door1.centerY;
                const minX = Math.min(door1.centerX, door2.centerX);
                const maxX = Math.max(door1.centerX, door2.centerX);
                
                for (let x = minX + layoutCellSize; x < maxX; x += layoutCellSize) { 
                    const col = Math.floor(x / layoutCellSize);
                    const rowTop = Math.floor((y - tunnelWidth / 2) / layoutCellSize);
                    const rowBottom = Math.floor((y + tunnelWidth / 2) / layoutCellSize);
                    
                    for (let row = rowTop; row <= rowBottom; row++) {
                        if (row >= 0 && row < layoutGridSize && col >= 0 && col < layoutGridSize) {
                            const obstacleId = layoutGridData[row][col];
                            
                            if (obstacleId !== null && obstacleId !== module1Id && obstacleId !== module2Id) { 
                                return false; 
                            }
                        }
                    }
                }
            } else { // isVertical
                const x = door1.centerX;
                const minY = Math.min(door1.centerY, door2.centerY);
                const maxY = Math.max(door1.centerY, door2.centerY);
                
                for (let y = minY + layoutCellSize; y < maxY; y += layoutCellSize) {
                    const row = Math.floor(y / layoutCellSize);
                    const colLeft = Math.floor((x - tunnelWidth / 2) / layoutCellSize);
                    const colRight = Math.floor((x + tunnelWidth / 2) / layoutCellSize);
                    
                    for (let col = colLeft; col <= colRight; col++) {
                        if (row >= 0 && row < layoutGridSize && col >= 0 && col < layoutGridSize) {
                            const obstacleId = layoutGridData[row][col];
                            
                            if (obstacleId !== null && obstacleId !== module1Id && obstacleId !== module2Id) {
                                return false; 
                            }
                        }
                    }
                }
            }

            return true;
        }

        function createTunnel(door1Index, door2Index) {
            layoutTunnels.push({
                door1Index: door1Index,
                door2Index: door2Index
            });
        }
        
        function toggleLayoutConnectMode() {
            layoutConnectMode = !layoutConnectMode;
            selectedLayoutDoor1 = null;
            selectedLayoutDoor2 = null;
            const btn = document.getElementById('layoutConnectBtn');
            if (layoutConnectMode) {
                btn.style.background = '#ffc107';
                btn.textContent = 'Cancel Connection';
                selectedLayoutSize = null;
                layoutDeleteMode = false;
                document.getElementById('layoutDeleteBtn').style.background = '#ff5722';
                document.getElementById('layoutDeleteBtn').textContent = 'Delete Objects';
                document.querySelectorAll('.structure-option').forEach(opt => opt.classList.remove('selected'));
                alert('Connection Mode: Click two doors to connect them with a tunnel.');
            } else {
                btn.style.background = '#28a745';
                btn.textContent = 'Connect Doors';
            }
            document.querySelectorAll('.layout-door').forEach(door => door.classList.remove('selected'));
            updateLayoutModeIndicator();
        }
        
        function toggleLayoutDeleteMode() {
            layoutDeleteMode = !layoutDeleteMode;
            const btn = document.getElementById('layoutDeleteBtn');
            if (layoutDeleteMode) {
                btn.style.background = '#c62828';
                btn.textContent = 'Cancel Delete';
                selectedLayoutSize = null;
                layoutConnectMode = false;
                document.getElementById('layoutConnectBtn').style.background = '#28a745';
                document.getElementById('layoutConnectBtn').textContent = 'Connect Doors';
                document.querySelectorAll('.structure-option').forEach(opt => opt.classList.remove('selected'));
                document.querySelectorAll('.layout-door').forEach(door => door.classList.remove('selected'));
                selectedLayoutDoor1 = null;
                selectedLayoutDoor2 = null;
            } else {
                btn.style.background = '#ff5722';
                btn.textContent = 'Delete Objects';
            }
            updateLayoutModeIndicator();
            updateLayoutGrid();
        }
        
        function clearLayoutGrid() {
            if (confirm('Clear all structures from layout?')) {
                document.querySelectorAll('.layout-tunnel').forEach(tunnel => tunnel.remove());
                layoutGridData = Array(layoutGridSize).fill(null).map(() => Array(layoutGridSize).fill(null));
                layoutModulesPlaced = [];
                selectedLayoutSize = null;
                draggingLayoutModule = null;
                isDraggingLayout = false;
                layoutConnectMode = false;
                layoutDeleteMode = false;
                selectedLayoutDoor1 = null;
                selectedLayoutDoor2 = null;
                layoutTunnels = [];
                layoutDoors = [];
                habitatStructures.forEach(s => { s.size = null; s.layoutPosition = null; });

                updateLayoutGrid();
                drawLayoutCircles();
                updateLayoutModeIndicator();
                initStructureSizeSelector(); 
                document.getElementById('layoutConnectBtn').style.background = '#28a745';
                document.getElementById('layoutConnectBtn').textContent = 'Connect Doors';
                document.getElementById('layoutDeleteBtn').style.background = '#ff5722';
                document.getElementById('layoutDeleteBtn').textContent = 'Delete Objects';
                document.querySelectorAll('.structure-option').forEach(opt => opt.classList.remove('selected'));
            }
        }
        
        function updateLayoutModeIndicator() {
            const indicator = document.getElementById('layoutModeIndicator');
            if (layoutDeleteMode) {
                indicator.textContent = 'Mode: Delete (Click objects)';
                indicator.style.background = '#f8d7da';
                indicator.style.color = '#721c24';
            } else if (layoutConnectMode) {
                indicator.textContent = 'Mode: Connect Doors';
                indicator.style.background = '#fff3cd';
                indicator.style.color = '#856404';
            } else if (selectedLayoutSize) {
                indicator.textContent = 'Mode: Place ' + habitatStructures[selectedLayoutSize.structureIndex].name;
                indicator.style.background = '#d4edda';
                indicator.style.color = '#155724';
            } else {
                indicator.textContent = 'Mode: Move Structures';
                indicator.style.background = '#cce5ff';
                indicator.style.color = '#004085';
            }
        }
        
        function removeLayoutTunnelsForModule(module) {
            const moduleDoors = layoutDoors.filter(door => door.module.id === module.id);
            const doorIndices = moduleDoors.map(door => layoutDoors.indexOf(door));
            const tunnelElements = Array.from(document.querySelectorAll('.layout-tunnel'));
            const tunnelsToRemove = [];
            
            layoutTunnels.forEach((tunnel, index) => {
                if (tunnel.door1Index !== undefined && tunnel.door2Index !== undefined) {
                    if (doorIndices.includes(tunnel.door1Index) || doorIndices.includes(tunnel.door2Index)) {
                        tunnelsToRemove.push(index);
                        if (tunnelElements[index]) tunnelElements[index].remove();
                    }
                }
            });
            
            tunnelsToRemove.reverse().forEach(index => layoutTunnels.splice(index, 1));
        }

        // --- El resto de funciones (GoToPage3, initBuildingGrid, etc.) se mantienen sin cambios ---

        function goToPage3(idx) {
            currentStructureIndex = idx;
            hide('page0', 'page2', 'page5'); show('page3');
            document.getElementById('currentBuildingName').textContent = habitatStructures[idx].name;
            document.getElementById('currentBuildingTitle').textContent = `Designing: ${habitatStructures[idx].name}`;
            selectedCompartmentType = null;
            initBuildingGrid();
            initCompartmentsList();
            renderPlacedCompartments();
        }

        function goToPage3FromModule() {
            if (tempCompartmentBackup) currentCompartmentInstance.equipment = tempCompartmentBackup;
            tempCompartmentBackup = null;
            goToPage3(currentStructureIndex);
        }

        function saveAndGoBack() {
            tempCompartmentBackup = null;
            goToPage3(currentStructureIndex);
        }

        function initBuildingGrid() {
            const grid = document.getElementById('buildingGrid');
            grid.innerHTML = '';
            grid.addEventListener('mousemove', (e) => { if (!selectedCompartmentType) return; showCompartmentGhost(e); });
            grid.addEventListener('mouseleave', () => { document.getElementById('moduleGhost').style.display = 'none'; });
            grid.addEventListener('click', (e) => {
                if (!selectedCompartmentType) return;
                const gridRect = grid.getBoundingClientRect();
                const col = Math.floor((e.clientX - gridRect.left) / 82);
                const row = Math.floor((e.clientY - gridRect.top) / 82);
                if (row >= 0 && row < 4 && col >= 0 && col < 6) placeCompartment(row, col);
            });
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 6; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    grid.appendChild(cell);
                }
            }
        }

        function showCompartmentGhost(e) {
            const ghost = document.getElementById('moduleGhost');
            const grid = document.getElementById('buildingGrid');
            const gridRect = grid.getBoundingClientRect();
            const col = Math.floor((e.clientX - gridRect.left) / 82);
            const row = Math.floor((e.clientY - gridRect.top) / 82);
            if (row >= 0 && row < 4 && col >= 0 && col < 6) {
                const isValid = col + 1 <= 6 && row + 1 <= 4;
                ghost.style.display = 'flex';
                ghost.style.left = `${gridRect.left + col * 82}px`;
                ghost.style.top = `${gridRect.top + row * 82}px`;
                ghost.style.width = '80px';
                ghost.style.height = '80px';
                ghost.textContent = selectedCompartmentType;
                ghost.className = 'ghost-preview ' + (isValid ? 'valid' : 'invalid');
            } else { ghost.style.display = 'none'; }
        }

        function initCompartmentsList() {
            const container = document.getElementById('modulesList');
            container.innerHTML = '';
            // Iterar sobre las claves del objeto, que ya son los nombres de los módulos
            Object.keys(compartmentTypes).forEach(type => {
                const div = document.createElement('div');
                div.className = 'object-item';
                // Asumiendo que M1, M2, etc., representan compartimentos de 4m x 5m (8x10 celdas)
                div.innerHTML = `<strong>${type}</strong><div class="object-dimensions">4m × 5m</div>`;
                div.onclick = () => selectCompartmentType(type, div);
                container.appendChild(div);
            });
        }

        function selectCompartmentType(type, el) {
            selectedCompartmentType = type;
            document.querySelectorAll('#modulesList .object-item').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
        }

        function placeCompartment(row, col) {
            if (!selectedCompartmentType) return;
            const s = habitatStructures[currentStructureIndex];
            if (col + 1 > 6 || row + 1 > 4) { alert('Out of bounds'); return; }
            s.compartments.push({id: `${selectedCompartmentType}_${Date.now()}`, type: selectedCompartmentType, row, col, cellsW: 1, cellsH: 1, equipment: []});
            renderPlacedCompartments();
            selectedCompartmentType = null;
            document.querySelectorAll('#modulesList .object-item').forEach(e => e.classList.remove('selected'));
            document.getElementById('moduleGhost').style.display = 'none';
        }

        function renderPlacedCompartments() {
            const grid = document.getElementById('buildingGrid');
            document.querySelectorAll('.placed-module').forEach(el => el.remove());
            habitatStructures[currentStructureIndex].compartments.forEach((m, i) => {
                const div = document.createElement('div');
                div.className = 'placed-module';
                div.style.left = `${m.col * 82}px`;
                div.style.top = `${m.row * 82}px`;
                div.style.width = `${m.cellsW * 82 - 2}px`;
                div.style.height = `${m.cellsH * 82 - 2}px`;
                div.innerHTML = `${m.type}<br><small>(${(m.equipment || []).length} items)</small>`;
                div.addEventListener('dblclick', (e) => { e.stopPropagation(); e.preventDefault(); currentCompartmentInstance = m; goToPage5(); });
                div.addEventListener('contextmenu', (e) => { e.preventDefault(); e.stopPropagation(); if (confirm(`Remove "${m.type}"?`)) { habitatStructures[currentStructureIndex].compartments.splice(i, 1); renderPlacedCompartments(); }});
                grid.appendChild(div);
            });
        }

        function resetBuilding() {
            if (confirm('Clear all compartments?')) { currentCompartmentInstance.equipment = []; renderPlacedEquipment(); }
        }

        function goToPage5() {
            tempCompartmentBackup = JSON.parse(JSON.stringify(currentCompartmentInstance.equipment || []));
            currentRotation = 0; selectedEquipment = null;
            hide('page0', 'page2', 'page3'); show('page5');
            document.getElementById('breadcrumbBuilding').textContent = habitatStructures[currentStructureIndex].name;
            document.getElementById('breadcrumbModule').textContent = currentCompartmentInstance.type;
            document.getElementById('currentModuleTitle').textContent = `Designing: ${currentCompartmentInstance.type}`;
            document.getElementById('objectPreview').classList.add('hidden');
            initModuleGrid(); initEquipmentList(); renderPlacedEquipment();
        }

        function initModuleGrid() {
            const grid = document.getElementById('moduleGrid');
            grid.innerHTML = '';
            grid.addEventListener('mousemove', (e) => { if (!selectedEquipment) return; showEquipmentGhost(e); });
            grid.addEventListener('mouseleave', () => { document.getElementById('objectGhost').style.display = 'none'; });
            grid.addEventListener('click', (e) => {
                if (!selectedEquipment) return;
                const gridRect = grid.getBoundingClientRect();
                const col = Math.floor((e.clientX - gridRect.left) / 51);
                const row = Math.floor((e.clientY - gridRect.top) / 51);
                if (row >= 0 && row < 10 && col >= 0 && col < 8) placeEquipment(row, col);
            });
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    grid.appendChild(cell);
                }
            }
        }

        function showEquipmentGhost(e) {
            const ghost = document.getElementById('objectGhost');
            const grid = document.getElementById('moduleGrid');
            const gridRect = grid.getBoundingClientRect();
            const col = Math.floor((e.clientX - gridRect.left) / 51);
            const row = Math.floor((e.clientY - gridRect.top) / 51);
            if (row >= 0 && row < 10 && col >= 0 && col < 8) {
                // CORRECCIÓN: Accede a las propiedades w y h del objeto.
                const equipmentData = compartmentTypes[currentCompartmentInstance.type].objects[selectedEquipment];
                const w = equipmentData.w;
                const h = equipmentData.h;
                
                const cellsW = currentRotation % 180 === 0 ? Math.round(w * 2) : Math.round(h * 2);
                const cellsH = currentRotation % 180 === 0 ? Math.round(h * 2) : Math.round(w * 2);
                const isValid = col + cellsW <= 8 && row + cellsH <= 10;
                ghost.style.display = 'flex';
                ghost.style.left = `${gridRect.left + col * 51}px`;
                ghost.style.top = `${gridRect.top + row * 51}px`;
                ghost.style.width = `${cellsW * 51 - 1}px`;
                ghost.style.height = `${cellsH * 51 - 1}px`;
                ghost.textContent = selectedEquipment;
                ghost.className = 'ghost-preview ' + (isValid ? 'valid' : 'invalid');
            } else { ghost.style.display = 'none'; }
        }

        function initEquipmentList() {
            const container = document.getElementById('objectsList');
            container.innerHTML = '';
            const equips = compartmentTypes[currentCompartmentInstance.type].objects;
            Object.keys(equips).forEach(name => {
                // CORRECCIÓN: Accede a las propiedades w, h y img
                const data = equips[name];
                const w = data.w;
                const h = data.h;
                const img = data.img;

                const div = document.createElement('div');
                div.className = 'object-item';
                // Muestra la imagen en el listado de opciones
                div.innerHTML = `
                    <img src="img/${img}" alt="${name}" style="height: 30px; margin-right: 10px; vertical-align: middle;">
                    <strong>${name}</strong>
                    <div class="object-dimensions">${w}m × ${h}m</div>
                `;
                div.onclick = () => selectEquipment(name, div);
                container.appendChild(div);
            });
        }

        function selectEquipment(name, el) {
            selectedEquipment = name;
            document.querySelectorAll('#objectsList .object-item').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
            updateEquipmentPreview();
        }

        function updateEquipmentPreview() {
            const preview = document.getElementById('objectPreview');
            if (!selectedEquipment) { preview.classList.add('hidden'); return; }
            preview.classList.remove('hidden');
            
            // CORRECCIÓN: Accede a las propiedades w, h y img
            const equipmentData = compartmentTypes[currentCompartmentInstance.type].objects[selectedEquipment];
            const w = equipmentData.w;
            const h = equipmentData.h;
            const img = equipmentData.img;

            const cellsW = currentRotation % 180 === 0 ? Math.round(w * 2) : Math.round(h * 2);
            const cellsH = currentRotation % 180 === 0 ? Math.round(h * 2) : Math.round(w * 2);
            
            document.getElementById('previewDimensions').textContent = `${cellsW/2}m × ${cellsH/2}m (${cellsW}×${cellsH} cells)`;
            document.getElementById('previewRotation').textContent = `${currentRotation}°`;
            
            const previewGrid = document.getElementById('previewGrid');
            previewGrid.innerHTML = '';
            previewGrid.style.gridTemplateColumns = `repeat(${cellsW}, 20px)`;
            previewGrid.style.gridTemplateRows = `repeat(${cellsH}, 20px)`;
            
            // Renderiza la imagen directamente en el preview (con un solo div)
            const previewImageDiv = document.createElement('div');
            previewImageDiv.style.cssText = `
                grid-column: 1 / ${cellsW + 1};
                grid-row: 1 / ${cellsH + 1};
                display: flex;
                align-items: center;
                justify-content: center;
                background: white;
            `;
            previewImageDiv.innerHTML = `<img src="img/${img}" alt="${selectedEquipment}">`;
            previewGrid.appendChild(previewImageDiv);
            
            // Rellenar las celdas de la cuadrícula visual detrás de la imagen (manteniendo el estilo original)
            for (let r = 0; r < cellsH; r++) {
                for (let c = 0; c < cellsW; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'preview-cell filled';
                    previewGrid.appendChild(cell);
                }
            }
        }

        function rotateObjectPreview() {
            currentRotation = (currentRotation + 90) % 360;
            updateEquipmentPreview();
        }

        function placeEquipment(row, col) {
            if (!selectedEquipment) return;
            if (!currentCompartmentInstance.equipment) currentCompartmentInstance.equipment = [];
            
            // CORRECCIÓN: Accede a las propiedades w, h y img
            const equipmentData = compartmentTypes[currentCompartmentInstance.type].objects[selectedEquipment];
            const w = equipmentData.w;
            const h = equipmentData.h;
            const img = equipmentData.img;
            
            if (currentCompartmentInstance.equipment.find(o => o.name === selectedEquipment)) { alert('Already placed'); return; }
            
            const cellsW = currentRotation % 180 === 0 ? Math.round(w * 2) : Math.round(h * 2);
            const cellsH = currentRotation % 180 === 0 ? Math.round(h * 2) : Math.round(w * 2);
            
            if (col + cellsW > 8 || row + cellsH > 10) { alert('Out of bounds'); return; }
            
            currentCompartmentInstance.equipment.push({name: selectedEquipment, row, col, cellsW, cellsH, rotation: currentRotation, img: img});
            renderPlacedEquipment();
            selectedEquipment = null; currentRotation = 0;
            
            document.querySelectorAll('#objectsList .object-item').forEach(e => e.classList.remove('selected'));
            document.getElementById('objectPreview').classList.add('hidden');
            document.getElementById('objectGhost').style.display = 'none';
        }

        function renderPlacedEquipment() {
            const grid = document.getElementById('moduleGrid');
            document.querySelectorAll('.placed-object').forEach(el => el.remove());
            if (!currentCompartmentInstance.equipment) return;
            currentCompartmentInstance.equipment.forEach((obj, i) => {
                const div = document.createElement('div');
                div.className = 'placed-object';
                div.style.left = `${obj.col * 51}px`;
                div.style.top = `${obj.row * 51}px`;
                div.style.width = `${obj.cellsW * 51 - 1}px`;
                div.style.height = `${obj.cellsH * 51 - 1}px`;
                // CORRECCIÓN: Muestra la imagen en el objeto colocado
                div.innerHTML = `<img src="img/${obj.img}" alt="${obj.name}" style="transform: rotate(${obj.rotation}deg);">`;
                
                div.ondblclick = (e) => { e.stopPropagation(); if (confirm(`Remove "${obj.name}"?`)) { currentCompartmentInstance.equipment.splice(i, 1); renderPlacedEquipment(); }};
                grid.appendChild(div);
            });
        }

        function resetModule() {
            if (confirm('Clear all equipment?')) { currentCompartmentInstance.equipment = []; renderPlacedEquipment(); }
        }
        
        // **********************************************
        // FUNCIONES 3D (CON TÚNELES CORREGIDOS A PUERTA-A-PUERTA)
        // **********************************************

        function init3DViewer() {
            const viewerContainer = document.getElementById('viewer3d');
            while (viewerContainer.querySelector('canvas')) {
                viewerContainer.querySelector('canvas').remove();
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000814);
            scene.fog = new THREE.Fog(0x000814, 0, 500);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 20);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            viewerContainer.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
            scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            const floorGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x8a8a8a, roughness: 0.9, metalness: 0.1 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            const vertices = floorGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) vertices[i + 2] += Math.random() * 0.5;
            floorGeometry.attributes.position.needsUpdate = true;
            floorGeometry.computeVertexNormals();
            scene.add(floor);
            
            // Función auxiliar para obtener la posición 3D central de un módulo (X= Este-Oeste, Z= Norte-Sur)
            const getModule3DPosition = (building) => {
                const cellToMeter = 0.5;
                const sizeInCells = layoutModuleSizes[building.size] || 8;
                
                // Calcular la posición central 3D
                const posX = (building.layoutPosition.col + sizeInCells / 2) * cellToMeter - (layoutGridSize * cellToMeter / 2);
                const posZ = (building.layoutPosition.row + sizeInCells / 2) * cellToMeter - (layoutGridSize * cellToMeter / 2);
                
                return { 
                    posX, 
                    posZ, 
                    sizeMultiplier: building.size === 'small' ? 1 : building.size === 'medium' ? 1.25 : building.size === 'large' ? 1.5 : 1 
                };
            };
            
            // Mapa para almacenar las posiciones 3D de los módulos para referencia rápida
            const modulePositions = {};
            
            // 1. Renderizar Hábitats (Cúpulas)
            habitatStructures.forEach((building) => {
                if (!building.layoutPosition || !building.size) return;
                
                const { posX, posZ, sizeMultiplier } = getModule3DPosition(building);
                const domeRadius = 4 * sizeMultiplier;

                // Almacenar la posición y el radio 3D para la conexión de túneles
                modulePositions[building.id] = { posX, posZ, radius: domeRadius };

                const dome = new THREE.SphereGeometry(domeRadius, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                const domeMat = new THREE.MeshStandardMaterial({ color: 0x2a4858, roughness: 0.3, metalness: 0.8, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
                const domeMesh = new THREE.Mesh(dome, domeMat);
                
                domeMesh.position.set(posX, 0, posZ);
                domeMesh.castShadow = true;
                domeMesh.receiveShadow = true;
                scene.add(domeMesh);
                
                const light = new THREE.PointLight(0x00ffff, 1, 20);
                light.position.set(posX, 4, posZ);
                scene.add(light);
            });
            
            // 2. Renderizar Túneles (Cilindros) - PUERTA A PUERTA (Código corregido y re-integrado)
            layoutTunnels.forEach(tunnel => {
                const door1Data = layoutDoors[tunnel.door1Index];
                const door2Data = layoutDoors[tunnel.door2Index];
                if (!door1Data || !door2Data) return;

                // Variables de conversión
                const cellToMeter = 0.5;
                const gridOffset = layoutGridSize * cellToMeter / 2;
                
                // 1. Calcular posiciones 3D de las puertas desde el layout 2D
                const door1X = (door1Data.centerX / layoutCellSize) * cellToMeter - gridOffset;
                const door1Z = (door1Data.centerY / layoutCellSize) * cellToMeter - gridOffset;
                const door2X = (door2Data.centerX / layoutCellSize) * cellToMeter - gridOffset;
                const door2Z = (door2Data.centerY / layoutCellSize) * cellToMeter - gridOffset;

                // Puntos de conexión de las puertas a 1m de altura
                const startPoint = new THREE.Vector3(door1X, 1, door1Z);
                const endPoint = new THREE.Vector3(door2X, 1, door2Z);
                
                const finalDistance = startPoint.distanceTo(endPoint);
                const tunnelRadius = 0.5;
                
                if (finalDistance <= 0.1) return; 

                const tunnelGeometry = new THREE.CylinderGeometry(tunnelRadius, tunnelRadius, finalDistance, 16);
                const tunnelMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x616161, 
                    roughness: 0.7, 
                    metalness: 0.3 
                });
                const tunnelMesh = new THREE.Mesh(tunnelGeometry, tunnelMaterial);

                // Posicionar en el punto medio
                const midPoint = new THREE.Vector3().lerpVectors(startPoint, endPoint, 0.5);
                tunnelMesh.position.copy(midPoint);

                // Calcular la orientación del túnel
                const direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
                const up = new THREE.Vector3(0, 1, 0);

                // Crear quaternion para rotar el cilindro (que por defecto apunta hacia Y)
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(up, direction);
                tunnelMesh.setRotationFromQuaternion(quaternion);
                
                tunnelMesh.castShadow = true;
                tunnelMesh.receiveShadow = true;
                scene.add(tunnelMesh);
            });

            // Estrellas
            const starsGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for (let i = 0; i < 3000; i++) {
                starVertices.push((Math.random() - 0.5) * 2000, Math.random() * 500 + 100, (Math.random() - 0.5) * 2000);
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starsGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 1 }));
            scene.add(stars);
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('viewer3d').addEventListener('click', (e) => {
                if (e.target.id !== 'view2DButton' && e.target.id !== 'vrButton' && e.target.tagName !== 'BUTTON') document.body.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => { isPointerLocked = document.pointerLockElement === document.body; });
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': moveUp = true; e.preventDefault(); break;
                case 'ShiftLeft': moveDown = true; break;
            }
        }

        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'Space': moveUp = false; break;
                case 'ShiftLeft': moveDown = false; break;
            }
        }

        function onMouseMove(e) {
            if (!isPointerLocked) return;
            euler.setFromQuaternion(camera.quaternion);
            euler.y -= e.movementX * 0.002;
            euler.x -= e.movementY * 0.002;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            camera.quaternion.setFromEuler(euler);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            if (!isVRMode) {
                velocity.x -= velocity.x * 10.0 * 0.016;
                velocity.z -= velocity.z * 10.0 * 0.016;
                velocity.y -= velocity.y * 10.0 * 0.016;
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.y = Number(moveUp) - Number(moveDown);
                direction.normalize();
                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * 0.016;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * 0.016;
                if (moveUp || moveDown) velocity.y += direction.y * 100.0 * 0.016;
                camera.translateX(-velocity.x * 0.016);
                camera.translateY(velocity.y * 0.016);
                camera.translateZ(-velocity.z * 0.016);
                if (camera.position.y < 2) camera.position.y = 2;
            }
            renderer.render(scene, camera);
        }
        
        function enterVR() {
             alert("VR is a placeholder functionality and may not work in all browsers.");
        }
        
        function exitVR() {
             // Lógica de salida de VR
        }

        // --- FUNCIONES DE VISTA 2D ---
        
        function open2DView() {
            document.getElementById('viewer3d').classList.remove('active');
            document.getElementById('view2d').classList.add('active');
            render2DView();
        }

        function close2DView() {
            document.getElementById('view2d').classList.remove('active');
            document.getElementById('viewer3d').classList.add('active');
        }

        function render2DView() {
            const container = document.getElementById('buildings-2d-container');
            container.innerHTML = '';
            
            // Título del layout general
            const layoutTitle = document.createElement('h2');
            layoutTitle.style.cssText = 'color: #00a8e8; margin-bottom: 20px;';
            layoutTitle.textContent = '🗺️ General Layout - Habitat Structures';
            container.appendChild(layoutTitle);
            
            // Canvas para el layout general
            const layoutCanvas = document.createElement('div');
            layoutCanvas.style.cssText = 'background: #2a2a3e; padding: 30px; border-radius: 15px; margin-bottom: 40px; display: inline-block;';
            
            const layoutGrid = document.createElement('div');
            layoutGrid.style.cssText = `
                /* Se usa una cuadrícula virtual de 80x80 con celdas de 8px para dibujar los módulos */
                width: ${layoutGridSize * 8}px; 
                height: ${layoutGridSize * 8}px; 
                border: 2px solid #00ff88;
                background: rgba(255, 255, 255, 0.1);
                position: relative;
            `;
            
            // 1. Dibujar círculos y etiquetas de módulos
            layoutModulesPlaced.forEach((module, moduleIndex) => {
                // Factores de escala para el mapa 2D (8px por celda de layoutCellSize=15)
                const scaleFactor = 8 / layoutCellSize; 
                const squareSide = module.size * 8; 
                const diameter = squareSide * Math.sqrt(2);
                
                // Posiciones basadas en la celda superior izquierda del módulo
                const leftPos = module.col * 8; 
                const topPos = module.row * 8;
                
                const centerX = leftPos + squareSide / 2;
                const centerY = topPos + squareSide / 2;
                
                // Círculo del módulo
                const circle = document.createElement('div');
                circle.style.cssText = `
                    position: absolute;
                    border: 3px solid ${module.type === 'small' ? '#dc3545' : module.type === 'medium' ? '#28a745' : '#007bff'};
                    border-radius: 50%;
                    width: ${diameter}px;
                    height: ${diameter}px;
                    left: ${centerX - diameter/2}px;
                    top: ${centerY - diameter/2}px;
                    pointer-events: none;
                    background: rgba(158, 158, 158, 0.3); /* Simular interior */
                `;
                layoutGrid.appendChild(circle);
                
                // Etiqueta del módulo
                const label = document.createElement('div');
                const structureName = habitatStructures.find(s => s.layoutPosition && s.layoutPosition.row === module.row && s.layoutPosition.col === module.col);
                label.style.cssText = `
                    position: absolute;
                    left: ${centerX}px;
                    top: ${centerY}px;
                    transform: translate(-50%, -50%);
                    color: white;
                    font-weight: bold;
                    font-size: 10px;
                    text-align: center;
                    background: rgba(0,0,0,0.7);
                    padding: 2px 4px;
                    border-radius: 3px;
                    pointer-events: none;
                `;
                label.textContent = structureName ? structureName.name.replace('Habitat Structure ', 'H') : `M${moduleIndex + 1}`;
                layoutGrid.appendChild(label);
            });
            
            // 2. Dibujar túneles
            layoutTunnels.forEach(tunnel => {
                const door1 = layoutDoors[tunnel.door1Index];
                const door2 = layoutDoors[tunnel.door2Index];
                if (!door1 || !door2) return;
                
                const scaleFactor = 8 / layoutCellSize; 
                const tunnelWidth = 2 * layoutCellSize * scaleFactor;
                const isHorizontal = Math.abs(door1.centerY - door2.centerY) < layoutCellSize * 1.5;
                
                const tunnelEl = document.createElement('div');
                tunnelEl.style.cssText = `
                    position: absolute;
                    background: #616161;
                    pointer-events: none;
                `;
                
                if (isHorizontal) {
                    const minX = Math.min(door1.centerX, door2.centerX) * scaleFactor;
                    const maxX = Math.max(door1.centerX, door2.centerX) * scaleFactor;
                    tunnelEl.style.left = minX + 'px';
                    tunnelEl.style.top = (door1.centerY * scaleFactor - tunnelWidth/2) + 'px';
                    tunnelEl.style.width = (maxX - minX) + 'px';
                    tunnelEl.style.height = tunnelWidth + 'px';
                } else {
                    const minY = Math.min(door1.centerY, door2.centerY) * scaleFactor;
                    const maxY = Math.max(door1.centerY, door2.centerY) * scaleFactor;
                    tunnelEl.style.left = (door1.centerX * scaleFactor - tunnelWidth/2) + 'px';
                    tunnelEl.style.top = minY + 'px';
                    tunnelEl.style.width = tunnelWidth + 'px';
                    tunnelEl.style.height = (maxY - minY) + 'px';
                }
                
                layoutGrid.appendChild(tunnelEl);
            });
            
            layoutCanvas.appendChild(layoutGrid);
            container.appendChild(layoutCanvas);
            
            // Leyenda
            const legend = document.createElement('div');
            legend.style.cssText = 'color: #ccc; margin: 20px 0; font-size: 14px;';
            legend.innerHTML = `
                <strong style="color: #00a8e8;">Scale:</strong> Each cell = 0.5m | 
                <span style="color: #dc3545;">●</span> Small (4m) | 
                <span style="color: #28a745;">●</span> Medium (5m) | 
                <span style="color: #007bff;">●</span> Large (6m)
            `;
            container.appendChild(legend);
            
            // Separador
            const separator = document.createElement('hr');
            separator.style.cssText = 'border: 1px solid #00a8e8; margin: 40px 0;';
            container.appendChild(separator);
            
            // Detalles de cada estructura
            const detailsTitle = document.createElement('h2');
            detailsTitle.style.cssText = 'color: #00a8e8; margin-bottom: 20px;';
            detailsTitle.textContent = '🏗️ Interior Details - Compartments & Equipment';
            container.appendChild(detailsTitle);
            
            habitatStructures.forEach((building, buildingIdx) => {
                if (!building.layoutPosition) return; 
                
                const buildingDiv = document.createElement('div');
                buildingDiv.className = 'building-2d-view';
                
                buildingDiv.innerHTML = `
                    <h2 style="color: #00a8e8; margin-bottom: 20px;">
                        ${building.name} 
                        <span style="color: #00ff88; font-size: 18px;">(${building.size ? building.size.charAt(0).toUpperCase() + building.size.slice(1) : 'Unknown'})</span>
                    </h2>
                    <p style="color: #ccc; margin-bottom: 10px;">Compartments: ${building.compartments.length}</p>
                `;
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'building-2d-grid';
                
                // Dibuja la cuadrícula de compartimentos 6x4
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 6; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'building-2d-cell';
                        gridDiv.appendChild(cell);
                    }
                }
                
                // Coloca los módulos (compartimentos) sobre la cuadrícula
                building.compartments.forEach((module, moduleIdx) => {
                    const moduleDiv = document.createElement('div');
                    moduleDiv.className = 'module-2d-view';
                    
                    moduleDiv.style.left = `${module.col * 103}px`;
                    moduleDiv.style.top = `${module.row * 103}px`;
                    moduleDiv.style.width = `${module.cellsW * 103 - 3}px`;
                    moduleDiv.style.height = `${module.cellsH * 103 - 3}px`;
                    
                    moduleDiv.innerHTML = `${module.type.replace('M', 'C')}<br><small>${(module.equipment || []).length} items</small>`;
                    moduleDiv.onclick = () => toggleModuleDetail(buildingIdx, moduleIdx);
                    gridDiv.appendChild(moduleDiv);
                });
                
                buildingDiv.appendChild(gridDiv);
                container.appendChild(buildingDiv);
            });
        }
        
        function toggleModuleDetail(buildingIdx, moduleIdx) {
            const container = document.getElementById('buildings-2d-container');
            const existingDetail = document.getElementById(`module-detail-${buildingIdx}`);
            const buildingDivs = Array.from(container.children).filter(el => el.classList.contains('building-2d-view'));
            const buildingDiv = buildingDivs[buildingIdx];

            if (existingDetail) { 
                existingDetail.remove(); 
                return;
            }

            const placedStructures = habitatStructures.filter(b => b.layoutPosition);
            // CORRECCIÓN: Usar el índice de la estructura en la lista filtrada de estructuras colocadas
            const building = placedStructures[buildingIdx];
            const module = building.compartments[moduleIdx];
            
            const detailDiv = document.createElement('div');
            detailDiv.className = 'module-2d-detail';
            detailDiv.id = `module-detail-${buildingIdx}`;
            
            detailDiv.innerHTML = `
                <h3 style="color: #00ff88; margin-bottom: 15px;">📦 ${module.type} - Interior</h3>
                <p style="color: #ccc; margin-bottom: 15px;">Dimensions: 4m × 5m | Equipment: ${(module.equipment || []).length}</p>
            `;
            
            const objectsGrid = document.createElement('div');
            objectsGrid.className = 'module-2d-objects-grid';
            
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'module-2d-cell';
                    objectsGrid.appendChild(cell);
                }
            }
            
            if (module.equipment && module.equipment.length > 0) {
                module.equipment.forEach(obj => {
                    const objDiv = document.createElement('div');
                    objDiv.className = 'object-2d-view';
                    
                    objDiv.style.left = `${obj.col * 62}px`;
                    objDiv.style.top = `${obj.row * 62}px`;
                    objDiv.style.width = `${obj.cellsW * 62 - 2}px`;
                    objDiv.style.height = `${obj.cellsH * 62 - 2}px`;
                    
                    // CORRECCIÓN: Muestra la imagen del equipo
                    const rotation = obj.rotation || 0;
                    objDiv.innerHTML = `<img src="img/${obj.img}" alt="${obj.name}" style="transform: rotate(${rotation}deg);">`;
                    objectsGrid.appendChild(objDiv);
                });
            }
            
            detailDiv.appendChild(objectsGrid);
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'btn-presentation';
            closeBtn.style.marginTop = '20px';
            closeBtn.textContent = '✕ Close Interior View';
            closeBtn.onclick = () => { detailDiv.remove(); }; 
            
            buildingDiv.appendChild(detailDiv);
            
            detailDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }


        // Funciones auxiliares
        function hide(...ids) { ids.forEach(id => document.getElementById(id).classList.add('hidden')); }
        function show(id) { document.getElementById(id).classList.remove('hidden'); }

        // Inicialización
        updateResourceCalculations();
    </script>
</body>
</html>
